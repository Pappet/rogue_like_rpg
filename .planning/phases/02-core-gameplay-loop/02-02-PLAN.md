---
phase: 02-core-gameplay-loop
plan: 2
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - config.py
  - components/camera.py
  - services/render_service.py
  - main.py
autonomous: true
must_haves:
  truths:
    - "The game displays a portion of the map composed of layered sprites."
    - "The size of the rendered tiles is determined by a central configuration setting."
    - "The rendered map corresponds to the map data structures."
  artifacts:
    - path: "config.py"
      provides: "A configurable TILE_SIZE setting."
    - path: "services/render_service.py"
      provides: "A service to render map tiles with all their sprite layers."
    - path: "main.py"
      provides: "The main game loop, updated to render the layered map."
  key_links:
    - from: "services/render_service.py"
      to: "config.py"
      via: "Imports and uses TILE_SIZE and SpriteLayer enum."
    - from: "services/render_service.py"
      to: "map/tile.py"
      via: "Reads the `sprites` dictionary from Tile objects to draw them in order."
    - from: "main.py"
      to: "services/render_service.py"
      via: "Calls the render service in the game loop."
---

<objective>
This plan implements the rendering of the tile-based world. It introduces a configurable tile size, a camera for managing the viewport, and a rendering service updated to draw the multi-layered sprites for each tile.

Purpose: To visually represent the game world, addressing the requirements for configurable tile size and multi-layer sprite rendering.
Output: A visually rendered map on the screen that correctly draws layered sprites at a configurable size.
</objective>

<execution_context>
@/home/peter/.gemini/get-shit-done/workflows/execute-plan.md
@/home/peter/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-gameplay-loop/CONTEXT.md
@.planning/phases/02-core-gameplay-loop/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Configurable Tile Size</name>
  <files>config.py</files>
  <action>
    In `config.py`, add a new constant `TILE_SIZE`.
    Set its value to `32`.
    This addresses the `requirement_coverage` blocker by making the tile size a configurable constant.
  </action>
  <verify>
    The file `config.py` contains the `TILE_SIZE` constant.
  </verify>
  <done>
    The tile size is now centrally configured.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Camera Class</name>
  <files>components/camera.py</files>
  <action>
    Create a `Camera` class in `components/camera.py`.
    The class should have attributes for `x`, `y`, `width`, and `height`.
    The constructor should take `width` and `height` in pixels.
    It should have a method `apply(entity)` that adjusts an entity's position based on the camera's position.
    It should also have a method to convert pixel coordinates to tile coordinates.
  </action>
  <verify>
    The file `components/camera.py` exists and contains the `Camera` class with the specified attributes and methods.
  </verify>
  <done>
    The `Camera` class is defined and ready to be used by the rendering service.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Revised RenderService</name>
  <files>services/render_service.py</files>
  <action>
    Create a `RenderService` class in `services/render_service.py`.
    Import `TILE_SIZE` and `SpriteLayer` from `config`.
    Implement a `render_map` method that takes a `MapContainer` and a `Camera`.
    The method should:
    1. Iterate through the visible tiles based on the camera's view.
    2. For each tile, iterate through its `sprites` dictionary, sorted by the `SpriteLayer` enum order (e.g., `sorted(tile.sprites.items())`).
    3. For each sprite in the tile, draw it at the correct position and scale, using `TILE_SIZE`.
    This addresses the warning about rendering sprite layers. For now, rendering can be drawing the character from the sprite data.
  </action>
  <verify>
    The file `services/render_service.py` exists and contains a `RenderService` class capable of rendering layered sprites.
  </verify>
  <done>
    The `RenderService` is capable of rendering a map with layered sprites.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update Main Game Loop</name>
  <files>main.py</files>
  <action>
    Update the main game loop in `main.py` to use the `RenderService`.
    - Instantiate the `MapService`, `RenderService`, and `Camera`.
    - Create a sample map using the `MapService` that includes tiles with multiple sprite layers.
    - In the game loop, call the `render_map` method of the `RenderService` to draw the map.
  </action>
  <verify>
    Running `main.py` displays a text-based representation of the map, showing the top-most sprite for each tile.
  </verify>
  <done>
    The game now renders a multi-layered map on the screen.
  </done>
</task>

</tasks>

<verification>
- Running `main.py` displays a representation of the map.
- The rendering logic in `RenderService` correctly iterates through sprite layers in the order defined by the `SpriteLayer` enum.
- The rendering logic uses the `TILE_SIZE` from `config.py`.
</verification>

<success_criteria>
- The game world is visually represented, correctly implementing both configurable tile size and multi-layer sprite rendering.
</output>