---
phase: 02-core-gameplay-loop
plan: 3
type: execute
wave: 3
depends_on:
  - "02-02"
files_modified:
  - entities/player.py
  - entities/hero.py
  - services/party_service.py
  - main.py
autonomous: true
must_haves:
  truths:
    - "A party is represented on the map on the correct sprite layer."
    - "The player can move the party around the map, respecting tile walkability."
  artifacts:
    - path: "entities/player.py"
      provides: "The Player class, representing the party's position and data."
    - path: "main.py"
      provides: "The main game loop, handling player movement and updating tile data accordingly."
  key_links:
    - from: "main.py"
      to: "entities/player.py"
      via: "Updates the player's position based on input."
    - from: "main.py"
      to: "map/tile.py"
      via: "Modifies the `sprites` dictionary of tiles to show player movement."
---

<objective>
This plan introduces the concept of a player-controlled party. It defines the data structures for heroes and the party, and implements basic movement on the map, ensuring compatibility with the new layered sprite system.

Purpose: To allow the player to interact with the game world by moving a party of heroes, which correctly interacts with the layered tile map.
Output: A party that can be moved around the map by the player, with its sprite appearing on the correct layer.
</objective>

<execution_context>
@/home/peter/.gemini/get-shit-done/workflows/execute-plan.md
@/home/peter/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-gameplay-loop/CONTEXT.md
@.planning/phases/02-core-gameplay-loop/02-01-SUMMARY.md
@.planning/phases/02-core-gameplay-loop/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Hero Class</name>
  <files>entities/hero.py</files>
  <action>
    Create a `Hero` class in `entities/hero.py`.
    The class should have attributes like `name`, `hp`, `max_hp`, etc.
    This will be a simple data class for now.
  </action>
  <verify>
    The file `entities/hero.py` exists and contains the `Hero` class.
  </verify>
  <done>
    The `Hero` class is defined.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Player Class</name>
  <files>entities/player.py</files>
  <action>
    Create a `Player` class in `entities/player.py`.
    The `Player` class represents the party.
    It should have attributes for `x` and `y` coordinates (in terms of tiles).
    It should also have a list of `Hero` objects and a `sprite` attribute (e.g., '@').
    Import the `Hero` class from `entities.hero`.
  </action>
  <verify>
    The file `entities/player.py` exists and contains the `Player` class.
  </verify>
  <done>
    The `Player` class is defined.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create PartyService</name>
  <files>services/party_service.py</files>
  <action>
    Create a `PartyService` in `services/party_service.py`.
    This service will be responsible for creating and managing the player's party.
    For now, create a placeholder class.
  </action>
  <verify>
    The file `services/party_service.py` exists and contains the `PartyService` class.
  </verify>
  <done>
    A placeholder for the `PartyService` is in place.
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement Player Movement on Layered Map</name>
  <files>main.py</files>
  <action>
    Update `main.py` to handle player movement on the layered map.
    - Instantiate the `Player` and place its sprite on the starting tile's `ENTITIES` layer.
    - In the game loop, check for keyboard input (arrow keys).
    - On input, determine the target tile.
    - Check if the target tile is `walkable`.
    - If walkable:
        1. Remove the player's sprite from the `ENTITIES` layer of the current tile.
        2. Update the player's coordinates.
        3. Add the player's sprite to the `ENTITIES` layer of the new tile.
    - This ensures the player's sprite is correctly managed in the tile data structure.
  </action>
  <verify>
    Running `main.py` allows the player to move a character on the map. The character sprite should appear above ground/decor but below top-level effects. The player should be blocked by non-walkable tiles.
  </verify>
  <done>
    The player can now move around the map, correctly interacting with the layered tile system.
  </done>
</task>

</tasks>

<verification>
- The player character is visible on the map, rendered on its correct layer.
- The player can be moved with the arrow keys.
- The player is blocked by tiles where `walkable` is False.
</verification>

<success_criteria>
- A movable player character exists on the map, correctly interacting with the revised layered sprite and tile system.
</output>