---
phase: 02-core-gameplay-loop
plan: 1
type: execute
wave: 1
depends_on: []
files_modified:
  - map/tile.py
  - map/map_layer.py
  - map/map_container.py
  - services/map_service.py
  - config.py
autonomous: true
must_haves:
  truths:
    - "A tile can hold multiple sprites on different, ordered layers."
    - "The game can represent a multi-layered map of tiles."
    - "A tile knows if it's walkable or not."
  artifacts:
    - path: "map/tile.py"
      provides: "Definition of a single tile, supporting layered sprites."
    - path: "config.py"
      provides: "Definitions for sprite layer ordering."
    - path: "map/map_layer.py"
      provides: "A container for a grid of tiles."
    - path: "map/map_container.py"
      provides: "A container for multiple map layers."
  key_links:
    - from: "map/tile.py"
      to: "config.py"
      via: "Uses the SpriteLayer enum for its sprite dictionary keys."
    - from: "map/map_container.py"
      to: "map/map_layer.py"
      via: "Contains a list of MapLayer objects."
    - from: "map/map_layer.py"
      to: "map/tile.py"
      via: "Contains a 2D array of Tile objects."
---

<objective>
This plan creates the foundational data structures for the tile-based map system. It will define the concepts of Tiles with multiple sprite layers, Map Layers, and Map Containers, which are essential for building the game world in accordance with the project's design decisions.

Purpose: To establish a robust and extensible data model for the game's world that supports layered sprites.
Output: Python classes for Tile, MapLayer, MapContainer, a MapService, and configuration for sprite layers.
</objective>

<execution_context>
@/home/peter/.gemini/get-shit-done/workflows/execute-plan.md
@/home/peter/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-gameplay-loop/CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Sprite Layers</name>
  <files>config.py</files>
  <action>
    In `config.py`, create a new `Enum` called `SpriteLayer`.
    This enum will define the fixed rendering order for sprite layers on a tile, as specified in CONTEXT.md.
    The layers should be:
    - `GROUND = 0`
    - `DECOR_BOTTOM = 1`
    - `TRAPS = 2`
    - `ITEMS = 3`
    - `CORPSES = 4`
    - `ENTITIES = 5`
    - `DECOR_TOP = 6`
    - `EFFECTS = 7`
    This addresses the `context_compliance` blocker by establishing the required layering system.
  </action>
  <verify>
    The file `config.py` contains the `SpriteLayer` enum with all specified layers in the correct order.
  </verify>
  <done>
    The sprite layering system is formally defined and ready for use.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Revised Tile Class</name>
  <files>map/tile.py</files>
  <action>
    Create a `Tile` class in `map/tile.py`.
    Import `SpriteLayer` from `config`.
    The class should have the following attributes:
    - `walkable`: A boolean indicating if the tile can be walked on. Determined by the ground layer.
    - `transparent`: A boolean indicating if the tile blocks line of sight.
    - `dark`: A boolean indicating if the tile is lit or not.
    - `sprites`: A dictionary where keys are `SpriteLayer` members and values are sprite identifiers (e.g., a character or sprite ID). This replaces the single 'sprite' attribute.
    This change is critical to align with the user decision for a multi-layer sprite system.
  </action>
  <verify>
    The file `map/tile.py` exists and contains the `Tile` class with a `sprites` dictionary instead of a single `sprite` attribute.
  </verify>
  <done>
    The `Tile` class is defined with support for layered sprites.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create MapLayer and MapContainer Classes</name>
  <files>
    - map/map_layer.py
    - map/map_container.py
  </files>
  <action>
    - In `map/map_layer.py`, create a `MapLayer` class that holds a 2D grid (`tiles`) of `Tile` objects. It should import `Tile` from `map.tile`.
    - In `map/map_container.py`, create a `MapContainer` class that holds a list (`layers`) of `MapLayer` objects. It should import `MapLayer` from `map.map_layer`.
    These classes remain structurally the same but will now contain the revised `Tile` objects.
  </action>
  <verify>
    The files `map/map_layer.py` and `map/map_container.py` exist and contain the respective classes.
  </verify>
  <done>
    The container classes for the map structure are defined.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create MapService</name>
  <files>services/map_service.py</files>
  <action>
    Create a placeholder `MapService` class in `services/map_service.py`.
    This service will be responsible for creating and managing map data.
  </action>
  <verify>
    The file `services/map_service.py` exists and contains the `MapService` class.
  </verify>
  <done>
    A placeholder for the `MapService` is in place for future development.
  </done>
</task>

</tasks>

<verification>
- All created files are syntactically correct Python.
- The `Tile` class correctly uses a dictionary for `sprites`, keyed by the `SpriteLayer` enum.
</verification>

<success_criteria>
- The data structures for the game map are created, correctly implementing the multi-layer sprite requirement.
</output>