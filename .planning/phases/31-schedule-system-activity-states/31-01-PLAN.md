---
phase: 31-schedule-system-activity-states
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [ecs/components.py, ecs/systems/schedule_system.py, ecs/systems/ai_system.py, game_states.py, entities/entity_factory.py]
autonomous: true

must_haves:
  truths:
    - "AIState enum includes WORK, PATROL, and SOCIALIZE states"
    - "ScheduleSystem identifies current schedule entry based on WorldClockService.hour"
    - "ScheduleSystem updates AIBehaviorState.state and PathData.destination when schedule changes"
    - "NPCs with a schedule receive an Activity component automatically"
  artifacts:
    - path: "ecs/systems/schedule_system.py"
      provides: "ScheduleSystem processor"
    - path: "ecs/components.py"
      provides: "Expanded AIState and Activity component"
  key_links:
    - from: "game_states.py"
      to: "ecs/systems/schedule_system.py"
      via: "Explicit process() call in Game.update"
---

<objective>
Implement the ScheduleSystem skeleton and integrate it with the WorldClockService and ScheduleRegistry. 
The system will handle the logic for finding the current schedule entry for an entity and updating its AI state and pathfinding target.

Purpose: Enable NPCs to follow time-driven routines.
Output: Working ScheduleSystem, updated components, and integration into the game loop.
</objective>

<execution_context>
@/home/peter/.gemini/get-shit-done/workflows/execute-plan.md
@/home/peter/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@ecs/components.py
@ecs/systems/ai_system.py
@services/world_clock_service.py
@entities/schedule_registry.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Components and Factory</name>
  <files>ecs/components.py, entities/entity_factory.py</files>
  <action>
    - Update `AIState` enum in `ecs/components.py` to include: `WORK = "work"`, `PATROL = "patrol"`, `SOCIALIZE = "socialize"`, `SLEEP = "sleep"`.
    - Add `Activity` component in `ecs/components.py`:
      ```python
      @dataclass
      class Activity:
          current_activity: str = "IDLE"
          target_pos: Optional[Tuple[int, int]] = None
      ```
    - Update `EntityFactory.create` in `entities/entity_factory.py` to add `Activity()` component to entities that have a `schedule_id`.
  </action>
  <verify>
    python -c "from ecs.components import AIState, Activity; print(AIState.WORK); print(Activity())"
  </verify>
  <done>AIState is expanded and Activity component is available and attached by factory.</done>
</task>

<task type="auto">
  <name>Task 2: Implement ScheduleSystem</name>
  <files>ecs/systems/schedule_system.py</files>
  <action>
    - Create `ecs/systems/schedule_system.py` with `ScheduleSystem(esper.Processor)`.
    - Implement `process(world_clock_service, map_container)`:
      - Iterate over entities with `(Schedule, AIBehaviorState, Activity, Position)`.
      - Get `ScheduleTemplate` from `ScheduleRegistry` using `Schedule.schedule_id`.
      - Find the `ScheduleEntry` matching `world_clock_service.hour`.
      - Check if the entry represents a new activity or target (compare with `Activity.current_activity` and `Activity.target_pos`).
      - On change:
        - Update `Activity.current_activity` and `Activity.target_pos`.
        - Update `AIBehaviorState.state` using a mapping (e.g., "WORK" -> AIState.WORK).
        - If `entry.target_pos` is not None:
          - Update `PathData.destination` to `entry.target_pos`.
          - Compute a new `PathData.path` using `PathfindingService.get_path`.
          - Ensure `PathData` component exists on the entity (add if missing).
  </action>
  <verify>
    Create a temporary test script that mocks WorldClockService and verifies ScheduleSystem updates an entity's state and path.
  </verify>
  <done>ScheduleSystem correctly transitions NPC states and updates pathfinding targets based on time.</done>
</task>

<task type="auto">
  <name>Task 3: AISystem Update and Loop Wiring</name>
  <files>ecs/systems/ai_system.py, game_states.py</files>
  <action>
    - Update `AISystem._dispatch` in `ecs/systems/ai_system.py`:
      - Add cases to the `match behavior.state` block for `AIState.WORK`, `AIState.PATROL`, `AIState.SOCIALIZE`, and `AIState.SLEEP` (as `pass` for now).
      - Note: The existing "PathData Priority" block already handles moving towards the target.
    - Update `game_states.py`:
      - Import `ScheduleSystem`.
      - Initialize `self.schedule_system = ScheduleSystem()` in `startup`.
      - In `update()`, call `self.schedule_system.process(self.world_clock, self.map_container)` immediately before `self.ai_system.process(...)`.
  </action>
  <verify>
    Check that the game runs without errors and NPCs with schedules have their state updated in the console (if logging added).
  </verify>
  <done>ScheduleSystem is integrated into the game loop and AISystem supports the new states.</done>
</task>

</tasks>

<verification>
### Automated Verification
1. Create `tests/verify_schedule_system.py` to test the full lifecycle:
   - Load a dummy schedule.
   - Create an NPC with that schedule.
   - Advance the clock.
   - Run `ScheduleSystem.process`.
   - Verify `Activity`, `AIState`, and `PathData` updates.

### Manual Verification
- Observe logs (if added) to see NPCs changing states at hour boundaries.
</verification>

<success_criteria>
1. ScheduleSystem correctly identifies and applies schedule entries based on world time.
2. NPCs transition to WORK, PATROL, or SOCIALIZE states according to their JSON routines.
3. NPCs move towards their scheduled target positions using the PathfindingService.
4. Existing behaviors (WANDER, CHASE) remain functional and unaffected for NPCs without schedules.
</success_criteria>

<output>
After completion, create `.planning/phases/31-schedule-system-activity-states/31-01-SUMMARY.md`
</output>
