---
phase: 05-nested-world-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ecs/components.py
  - map/map_container.py
  - services/map_service.py
autonomous: true
must_haves:
  truths:
    - "MapService can store multiple maps by ID"
    - "MapContainer can freeze (store) and thaw (restore) entities"
    - "Portal component exists with target coordinates and layer"
    - "Position component includes a layer index"
  artifacts:
    - path: "ecs/components.py"
      provides: "Portal component, Position.layer"
    - path: "map/map_container.py"
      provides: "freeze/thaw methods"
    - path: "services/map_service.py"
      provides: "Map repository logic"
  key_links:
    - from: "services/map_service.py"
      to: "map/map_container.py"
      via: "manages instances of"
    - from: "map/map_container.py"
      to: "ecs/components.py"
      via: "serializes component data"
---

<objective>
Implement the foundational data structures for nested worlds: the Portal component, entity persistence in MapContainer, and a repository-style MapService.

Purpose: Enable the game to manage multiple map instances and preserve their state (entities) when the player is not present.
Output: Updated component definitions and map management services.
</objective>

<execution_context>
@/home/peter/.gemini/get-shit-done/workflows/execute-plan.md
@/home/peter/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/05-nested-world-architecture/05-RESEARCH.md
@ecs/components.py
@map/map_container.py
@services/map_service.py
</context>

<tasks>

<task type="auto">
  <name>Update Components</name>
  <files>ecs/components.py</files>
  <action>
    1. Update `Position` dataclass to include `layer: int = 0`.
    2. Create `Portal` dataclass with fields:
       - `target_map_id: str`
       - `target_x: int`
       - `target_y: int`
       - `target_layer: int = 0`
       - `name: str = "Portal"` (optional, for UI)
  </action>
  <verify>
    Create a script `tests/verify_components.py` that instantiates `Position` and `Portal` and prints them to ensure fields exist.
  </verify>
  <done>
    `Position` has layer field; `Portal` component exists.
  </done>
</task>

<task type="auto">
  <name>Implement Entity Persistence in MapContainer</name>
  <files>map/map_container.py</files>
  <action>
    1. Add `frozen_entities: List[dict] = field(default_factory=list)` to `MapContainer`. (Import `field` from dataclasses or initialize in `__init__`).
    2. Implement `freeze(self, world, exclude_entities: list)`:
       - Iterate over all entities in `world` (using `esper`).
       - If entity ID is NOT in `exclude_entities`:
         - Extract all components (Position, Renderable, Name, Stats, etc.).
         - Serialize them into a dictionary (or pickleable object).
         - Add to `self.frozen_entities`.
         - Delete entity from `world`.
    3. Implement `thaw(self, world)`:
       - Iterate over `self.frozen_entities`.
       - Create new entity in `world`.
       - Re-attach all components.
       - Clear `self.frozen_entities`.
    
    *Note:* For serialization, since components are dataclasses, you can store them as-is if using `pickle`, or convert to dicts if aiming for JSON later. For now, storing the component *instances* in a list is sufficient for in-memory persistence.
  </action>
  <verify>
    Create `tests/verify_persistence.py`:
    - Create a world and an entity.
    - Create MapContainer.
    - Call `map.freeze(world)`.
    - Assert world is empty (except excluded).
    - Call `map.thaw(world)`.
    - Assert entity exists with same data.
  </verify>
  <done>
    Entities can be moved from World to MapContainer and back.
  </done>
</task>

<task type="auto">
  <name>Refactor MapService to Repository Pattern</name>
  <files>services/map_service.py</files>
  <action>
    1. Update `MapService.__init__`:
       - Initialize `self.maps: Dict[str, MapContainer] = {}`.
       - Initialize `self.active_map_id: str = None`.
    2. Add `register_map(self, map_id: str, container: MapContainer)`:
       - Store container in `self.maps`.
    3. Add `get_map(self, map_id: str) -> MapContainer`:
       - Return map from `self.maps`.
    4. Add `get_active_map(self) -> MapContainer`:
       - Return map for `self.active_map_id`.
    5. Add `set_active_map(self, map_id: str)`:
       - Update `self.active_map_id`.
    6. Update `create_sample_map` (or add `create_map`) to optionally register the map under an ID.
  </action>
  <verify>
    Create `tests/verify_map_service.py`:
    - Register two maps.
    - Switch active map.
    - Verify `get_active_map` returns correct map.
  </verify>
  <done>
    MapService manages a collection of named maps.
  </done>
</task>

</tasks>

<verification>
Run the created verification scripts:
- `python3 tests/verify_components.py`
- `python3 tests/verify_persistence.py`
- `python3 tests/verify_map_service.py`
</verification>

<success_criteria>
- Project code compiles (no syntax errors in new components).
- MapService can store and retrieve maps by ID.
- Entities can be frozen (removed from world, stored) and thawed (restored to world).
</success_criteria>

<output>
After completion, create `.planning/phases/05-nested-world-architecture/05-01-SUMMARY.md`
</output>
