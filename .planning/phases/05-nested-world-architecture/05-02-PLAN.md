---
phase: 05-nested-world-architecture
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - ecs/systems/action_system.py
  - game_states.py
  - ecs/systems/movement_system.py
  - ecs/systems/visibility_system.py
  - ecs/systems/render_system.py
autonomous: true
must_haves:
  truths:
    - "Player can trigger EnterPortal action"
    - "Game transitions to new map upon portal entry"
    - "Entities on old map are saved"
    - "Player appears at correct coordinates and layer on new map"
  artifacts:
    - path: "game_states.py"
      provides: "Map transition logic (freeze/switch/thaw)"
    - path: "ecs/systems/action_system.py"
      provides: "EnterPortal detection"
  key_links:
    - from: "ecs/systems/action_system.py"
      to: "game_states.py"
      via: "Event dispatch (change_map)"
    - from: "game_states.py"
      to: "services/map_service.py"
      via: "get_map / set_active_map"
---

<objective>
Implement the logic for transitioning between maps using Portals. This involves updating the ActionSystem to detect portal usage, and the Game state to orchestrate the map switch (handling persistence and system updates).

Purpose: Enable actual navigation between nested worlds.
Output: Working portal transition system.
</objective>

<execution_context>
@/home/peter/.gemini/get-shit-done/workflows/execute-plan.md
@/home/peter/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/05-nested-world-architecture/05-01-SUMMARY.md
@game_states.py
@ecs/systems/action_system.py
</context>

<tasks>

<task type="auto">
  <name>Update Systems for Layer/Map Awareness</name>
  <files>ecs/systems/movement_system.py, ecs/systems/visibility_system.py, ecs/systems/render_system.py</files>
  <action>
    1. Update `MovementSystem`:
       - Add `set_map(self, map_container)` method.
       - In `process`, use `Position.layer` when calling `map.get_tile(x, y, layer)`.
    2. Update `VisibilitySystem`:
       - Add `set_map(self, map_container)` method.
       - In `process`, use `Position.layer` (if relevant for FOV) or assume layer 0 for now if FOV is 2D. *Decision: Pass layer to get_tile if available.*
    3. Update `RenderSystem`:
       - Add `set_map(self, map_container)` method.
       - Ensure it renders the correct map layers.
  </action>
  <verify>
    Code analysis: Ensure systems reference `self.map` which is updated via `set_map`.
  </verify>
  <done>
    Systems can be dynamically repointed to a new map instance.
  </done>
</task>

<task type="auto">
  <name>Implement Enter Portal Action</name>
  <files>ecs/systems/action_system.py</files>
  <action>
    1. Define `PortalAction` (or handle generic "Interact").
    2. In `ActionSystem.perform_action` (or equivalent):
       - If action is "Enter Portal" (or generic interact):
         - Get player position.
         - Query world for `Portal` entities at that (x, y).
         - If found, dispatch `change_map` event with `(target_map_id, target_x, target_y, target_layer)`.
         - Log "Enters portal..." message.
  </action>
  <verify>
    Mock test: Place portal and player at (1,1). Trigger action. Verify event dispatched (mock esper.dispatch_event).
  </verify>
  <done>
    Standing on a portal and acting triggers a map change request.
  </done>
</task>

<task type="auto">
  <name>Implement Transition Orchestrator in Game State</name>
  <files>game_states.py</files>
  <action>
    1. In `Game` class:
       - Add a method `transition_map(self, target_map_id, target_x, target_y, target_layer)`.
    2. Implement logic:
       - `current_map = self.map_service.get_active_map()`
       - `current_map.freeze(self.world, exclude=[self.player_entity])`
       - `new_map = self.map_service.get_map(target_map_id)`
       - `self.map_service.set_active_map(target_map_id)`
       - `self.map_container = new_map`
       - `new_map.thaw(self.world)`
       - Update Player `Position`: x, y, layer.
       - Update Systems: `self.movement_system.set_map(new_map)`, `visibility_system`, etc.
       - Update `self.camera` (snap to new player pos).
    3. Register listener for `change_map` event to call `transition_map`.
  </action>
  <verify>
    Integration test in Plan 03.
  </verify>
  <done>
    Game state can successfully swap maps and preserve entities.
  </done>
</task>

</tasks>

<verification>
Manual verification via Plan 05-03.
Check that `game_states.py` imports `MapService` correctly and uses the API defined in 05-01.
</verification>

<success_criteria>
- `Game` class handles `change_map` event.
- Systems are updated with new map reference upon transition.
- Player position is updated to portal target.
</success_criteria>

<output>
After completion, create `.planning/phases/05-nested-world-architecture/05-02-SUMMARY.md`
</output>
