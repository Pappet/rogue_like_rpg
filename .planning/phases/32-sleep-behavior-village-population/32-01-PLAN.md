---
phase: 32-sleep-behavior-village-population
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [ecs/systems/ai_system.py, ecs/systems/render_system.py, ecs/systems/action_system.py, ecs/systems/combat_system.py, ecs/systems/movement_system.py, game_states.py]
autonomous: true

must_haves:
  truths:
    - "NPCs in SLEEP state do not move even if they have PathData"
    - "NPCs in SLEEP state do not detect the player"
    - "Sleeping NPCs are rendered with dimmed colors (50% brightness)"
    - "Attacking a sleeping NPC wakes them up (sets state to IDLE)"
    - "Bumping into a sleeping NPC wakes them up (sets state to IDLE)"
  artifacts:
    - path: "ecs/systems/ai_system.py"
      provides: "Sleep turn skipping"
    - path: "ecs/systems/render_system.py"
      provides: "Sleep visual dimming"
    - path: "ecs/systems/action_system.py"
      provides: "Centralized wake_up logic"
  key_links:
    - from: "ecs/systems/movement_system.py"
      to: "ecs/systems/action_system.py"
      via: "wake_up call on bump"
    - from: "ecs/systems/combat_system.py"
      to: "ecs/systems/action_system.py"
      via: "wake_up call on hit"
---

<objective>
Implement core sleep mechanics: turn skipping, player detection suppression, visual dimming, and wake-up triggers for bumping and combat.

Purpose: Essential foundation for NPC daily routines where characters must rest without engaging the player or moving.
Output: NPCs that stay in place and ignore the player while sleeping, appearing dimmed, but react to physical contact or damage.
</objective>

<execution_context>
@/home/peter/.gemini/get-shit-done/workflows/execute-plan.md
@/home/peter/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@ecs/components.py
@ecs/systems/ai_system.py
@ecs/systems/render_system.py
@ecs/systems/action_system.py
@ecs/systems/combat_system.py
@ecs/systems/movement_system.py
@game_states.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: AI and Rendering Sleep Logic</name>
  <files>ecs/systems/ai_system.py, ecs/systems/render_system.py</files>
  <action>
    1. Update `AISystem._dispatch`:
       - Add a check at the very beginning of the method: `if behavior.state == AIState.SLEEP: return`.
       - This ensures sleeping NPCs skip detection, path following, and all other behaviors.
    2. Update `RenderSystem.process`:
       - Import `AIBehaviorState` and `AIState`.
       - Inside the entity render loop, after depth darkening calculations:
       - Check if entity has `AIBehaviorState`.
       - If `behavior.state == AIState.SLEEP`, multiply the final `color` tuple values by `0.5` (cast to `int`).
  </action>
  <verify>
    Run `python -c "from ecs.components import AIState; print(AIState.SLEEP)"` to ensure enum exists.
    Visual check (manual or via test) that sleeping NPCs don't move and appear dark.
  </verify>
  <done>
    AISystem skips turns for SLEEP state. RenderSystem dims SLEEP entities.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wake-up Logic and System Wiring</name>
  <files>ecs/systems/action_system.py, ecs/systems/combat_system.py, ecs/systems/movement_system.py, game_states.py</files>
  <action>
    1. Update `ActionSystem`:
       - Import `AIBehaviorState`, `AIState`, `Name`.
       - Add `wake_up(self, target_entity)` method.
       - Logic: If target has `AIBehaviorState` and `state == AIState.SLEEP`, set `state = AIState.IDLE`.
       - Dispatch log message: `f"The {name} wakes up!"`.
    2. Update `MovementSystem`:
       - Update `__init__` to accept `action_system`.
       - In `process`, when a `blocker_ent` is detected:
       - Before adding `AttackIntent`, check if `blocker_ent` has `AIBehaviorState` and is in `AIState.SLEEP`.
       - If so, call `self.action_system.wake_up(blocker_ent)`.
    3. Update `CombatSystem`:
       - Update `__init__` to accept `action_system`.
       - In `process`, after damage is applied and before death check:
       - Check if `target` has `AIBehaviorState` and is in `AIState.SLEEP`.
       - If so, call `self.action_system.wake_up(target)`.
    4. Update `game_states.py`:
       - Pass `self.action_system` to both `MovementSystem` and `CombatSystem` constructors.
  </action>
  <verify>
    Check that `MovementSystem` and `CombatSystem` now take `action_system` as an argument.
    Verify that bumping a sleeping entity triggers a log message.
  </verify>
  <done>
    NPCs wake up from bumps and hits. Systems are correctly wired.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verification of Sleep Mechanics</name>
  <files>tests/verify_sleep_mechanics.py</files>
  <action>
    Create a new test script `tests/verify_sleep_mechanics.py` that:
    1. Sets up an NPC in `AIState.SLEEP`.
    2. Verifies `AISystem` does not move it even with `PathData`.
    3. Verifies bumping the NPC (via `MovementSystem`) changes its state to `IDLE`.
    4. Verifies attacking the NPC (via `CombatSystem`) changes its state to `IDLE`.
    5. Verifies `AISystem` detection block is skipped in `SLEEP`.
  </action>
  <verify>
    Run `pytest tests/verify_sleep_mechanics.py`
  </verify>
  <done>
    All sleep mechanics are verified via automated tests.
  </done>
</task>

</tasks>

<verification>
- NPCs in SLEEP state remain stationary and unresponsive.
- NPCs appear visibly darker when sleeping.
- Interaction (bump) or combat (attack) successfully wakes them.
</verification>

<success_criteria>
- `AISystem` skips turn processing for entities in `AIState.SLEEP`.
- `RenderSystem` applies 0.5 color multiplier to sleeping entities.
- `ActionSystem.wake_up()` centralized logic is implemented and used by `MovementSystem` and `CombatSystem`.
- `tests/verify_sleep_mechanics.py` passes.
</success_criteria>

<output>
After completion, create `.planning/phases/32-sleep-behavior-village-population/32-01-SUMMARY.md`
</output>
