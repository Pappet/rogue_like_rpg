---
phase: 34-input-handling-control-scheme
plan: 02
type: execute
wave: 2
depends_on: ["34-01"]
files_modified: [services/interaction_resolver.py, ecs/systems/movement_system.py, game_states.py]
autonomous: true

must_haves:
  truths:
    - "Walking into an entity with Stats (enemy) triggers an AttackIntent"
    - "Walking into a neutral/friendly entity triggers a Talk/Interact event"
    - "Player can move regardless of selected action in the UI action bar"
  artifacts:
    - path: "services/interaction_resolver.py"
      provides: "Logic to determine outcome of a bump interaction"
  key_links:
    - from: "ecs/systems/movement_system.py"
      to: "services/interaction_resolver.py"
      via: "interaction resolution on collision"
---

<objective>
Implement context-sensitive "Bump" interactions. This allows the player to interact with the world (attack enemies, talk to NPCs) simply by moving into them, without needing to select a specific action first.
</objective>

<execution_context>
@/home/peter/.gemini/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-input-handling-control-scheme/34-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Create InteractionResolver Service</name>
  <files>services/interaction_resolver.py</files>
  <action>
    Implement InteractionResolver in services/interaction_resolver.py.
    - Create a class or functions that take (source_entity, target_entity) and return an "InteractionType" or directly apply logic.
    - Logic should check entity components:
      - If target has Stats + Hostile Alignment: Return ATTACK.
      - If target has AIBehaviorState + SLEEP: Wake up (use action_system.wake_up).
      - If target is Interactive/NPC: Trigger TALK/INTERACT (placeholder for now, e.g., log message).
  </action>
  <verify>
    Write a small test script to verify InteractionResolver returns correct interaction for different components.
  </verify>
  <done>
    InteractionResolver correctly identifies intended actions on collision.
  </done>
</task>

<task type="auto">
  <name>Update MovementSystem and Input Handling</name>
  <files>ecs/systems/movement_system.py, game_states.py</files>
  <action>
    - Update MovementSystem to use InteractionResolver when a movement attempt is blocked by an entity.
    - Move existing "bump-to-attack" and "wake-up" logic from MovementSystem into InteractionResolver.
    - Update Game.handle_player_input in game_states.py to allow MOVE commands regardless of the selected action index in ActionList (unless in a state where movement is explicitly disabled). This enables "Bump-to-Action" by making movement always available.
  </action>
  <verify>
    Run the game and verify:
    - Walking into a monster attacks it.
    - Walking into a sleeping NPC wakes them up.
    - Moving works even if 'Move' is not the selected action in the UI.
  </verify>
  <done>
    Bump interactions are fully functional and movement is decoupled from UI action selection.
  </done>
</task>

</tasks>

<verification>
python tests/verify_range_movement.py (or similar functional test)
Run game: Bump into enemy, bump into villager.
</verification>

<success_criteria>
1. Bumping into an enemy triggers an attack without selecting an action first.
2. Bumping into a friendly NPC triggers a "Talk" or "Interact" event (log message).
</success_criteria>

<output>
After completion, create .planning/phases/34-input-handling-control-scheme/34-02-SUMMARY.md
</output>
