---
phase: 34-input-handling-control-scheme
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [services/input_manager.py, main.py, game_states.py]
autonomous: true

must_haves:
  truths:
    - "Raw keypresses are translated into InputCommand enums"
    - "Different command maps are used based on the current GameState"
    - "GameStates and states in main.py use the new InputManager"
  artifacts:
    - path: "services/input_manager.py"
      provides: "Centralized input handling and command mapping"
  key_links:
    - from: "main.py"
      to: "services/input_manager.py"
      via: "event processing"
    - from: "game_states.py"
      to: "services/input_manager.py"
      via: "command handling"
---

<objective>
Centralize input handling by creating an InputManager service that maps raw Pygame keys to high-level commands based on the current game state. This decouples the low-level event loop from game logic.
</objective>

<execution_context>
@/home/peter/.gemini/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-input-handling-control-scheme/RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create InputManager Service</name>
  <files>services/input_manager.py</files>
  <action>
    Implement a centralized InputManager in services/input_manager.py.
    - Define an InputCommand Enum (e.g., MOVE_UP, MOVE_DOWN, INTERACT, OPEN_INVENTORY, CANCEL, CONFIRM, etc.).
    - Create an InputManager class with a mapping for different GameStates (PLAYER_TURN, TARGETING, TITLE, etc.).
    - Implement a method `handle_event(event, state)` that returns an InputCommand or None.
    - Include support for Arrow Keys, WASD (for menus/navigation), and functional keys (I, G, M, ESC, RETURN).
  </action>
  <verify>
    Run a unit test or simple script to verify that InputManager correctly maps pygame.K_UP to InputCommand.MOVE_UP in PLAYER_TURN state.
  </verify>
  <done>
    InputManager service exists and correctly maps keys to commands for current game states.
  </done>
</task>

<task type="auto">
  <name>Integrate InputManager into GameStates</name>
  <files>game_states.py, main.py</files>
  <action>
    Refactor game_states.py and main.py to use InputManager.
    - In GameController (main.py), initialize InputManager and pass it to states if needed, or make it a singleton/service accessed by states.
    - In Game.get_event (game_states.py), replace raw key checks with calls to InputManager.
    - Refactor handle_player_input and handle_targeting_input to switch on InputCommand enums instead of pygame.K_* constants.
    - Ensure debug keys (F3-F7) are also handled (either via InputManager or kept as special cases if they bypass the command system).
  </action>
  <verify>
    Run the game and verify that basic movement and menu navigation still work as expected.
  </verify>
  <done>
    All game states use InputManager for key-to-command translation.
  </done>
</task>

</tasks>

<verification>
python main.py (Verify movement, inventory opening, and targeting navigation work with new system)
</verification>

<success_criteria>
1. InputManager translates raw keypresses into high-level commands.
2. Codebase is free of direct pygame.K_* comparisons in input handlers.
</success_criteria>

<output>
After completion, create .planning/phases/34-input-handling-control-scheme/34-01-SUMMARY.md
</output>
