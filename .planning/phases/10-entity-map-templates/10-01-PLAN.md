---
phase: 10-entity-map-templates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - assets/data/entities.json
  - entities/entity_registry.py
  - entities/entity_factory.py
  - services/resource_loader.py
  - services/map_service.py
  - main.py
  - tests/verify_entity_factory.py
autonomous: true

must_haves:
  truths:
    - "An orc entity is spawned using stats and renderable data from entities.json, not hardcoded values"
    - "ResourceLoader.load_entities() populates EntityRegistry before any entity creation"
    - "ResourceLoader.load_tiles() is called in main.py before map/entity creation (fixes latent startup bug)"
    - "spawn_monsters() uses EntityFactory.create() instead of create_orc()"
  artifacts:
    - path: "assets/data/entities.json"
      provides: "Entity template definitions (at minimum: orc)"
      contains: '"id": "orc"'
    - path: "entities/entity_registry.py"
      provides: "EntityTemplate dataclass and EntityRegistry singleton"
      exports: ["EntityTemplate", "EntityRegistry"]
    - path: "entities/entity_factory.py"
      provides: "Factory that creates ECS entities from registry templates"
      exports: ["EntityFactory"]
    - path: "services/resource_loader.py"
      provides: "load_entities() static method added alongside existing load_tiles()"
      contains: "def load_entities"
    - path: "tests/verify_entity_factory.py"
      provides: "Verification tests for entity template loading and factory creation"
  key_links:
    - from: "main.py"
      to: "services/resource_loader.py"
      via: "ResourceLoader.load_tiles() and ResourceLoader.load_entities() called before create_village_scenario()"
      pattern: "ResourceLoader\\.load_(tiles|entities)"
    - from: "entities/entity_factory.py"
      to: "entities/entity_registry.py"
      via: "EntityFactory.create() looks up EntityTemplate from EntityRegistry.get()"
      pattern: "EntityRegistry\\.get"
    - from: "services/map_service.py"
      to: "entities/entity_factory.py"
      via: "spawn_monsters() calls EntityFactory.create() instead of create_orc()"
      pattern: "EntityFactory\\.create"
---

<objective>
Create the entity template system: JSON data file, registry, resource loader extension, and factory. Migrate all monster spawning to use the factory pattern. Fix the startup ordering bug where load_tiles() is never called in main.py.

Purpose: Moves entity definitions from hardcoded Python functions to external JSON configuration, enabling data-driven entity creation consistent with the Phase 9 tile registry pattern.
Output: Working EntityRegistry/EntityFactory pipeline with entities.json, verified by tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-entity-map-templates/10-RESEARCH.md
@map/tile_registry.py
@services/resource_loader.py
@entities/monster.py
@ecs/components.py
@services/map_service.py
@main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EntityRegistry, EntityFactory, entities.json, and extend ResourceLoader</name>
  <files>
    assets/data/entities.json
    entities/entity_registry.py
    entities/entity_factory.py
    services/resource_loader.py
  </files>
  <action>
1. Create `assets/data/entities.json` — a JSON array with at least the orc template. Fields must match the existing `create_orc()` values exactly:
   ```json
   [
     {
       "id": "orc",
       "name": "Orc",
       "sprite": "O",
       "color": [0, 255, 0],
       "sprite_layer": "ENTITIES",
       "hp": 10,
       "max_hp": 10,
       "power": 3,
       "defense": 0,
       "mana": 0,
       "max_mana": 0,
       "perception": 5,
       "intelligence": 5,
       "ai": true,
       "blocker": true
     }
   ]
   ```

2. Create `entities/entity_registry.py` — mirror `map/tile_registry.py` exactly:
   - `EntityTemplate` dataclass with fields: id, name, sprite, color (Tuple[int,int,int]), sprite_layer (str — raw string, NOT converted to enum at load time), hp, max_hp, power, defense, mana, max_mana, perception, intelligence, ai (bool, default True), blocker (bool, default True).
   - `EntityRegistry` class with class-level `_registry: Dict[str, EntityTemplate] = {}` and classmethods: `register(template)`, `get(template_id) -> Optional[EntityTemplate]`, `clear()`, `all_ids()`.

3. Create `entities/entity_factory.py`:
   - `EntityFactory` class with a single static method `create(world, template_id: str, x: int, y: int) -> int`.
   - Looks up template via `EntityRegistry.get(template_id)`. Raises `ValueError` with helpful message if not found.
   - Converts `template.sprite_layer` string to int via `SpriteLayer[template.sprite_layer].value`.
   - Builds component list: `Position(x, y)`, `Renderable(template.sprite, layer_enum_value, template.color)`, `Stats(hp=..., max_hp=..., power=..., defense=..., mana=..., max_mana=..., perception=..., intelligence=...)`, `Name(template.name)`.
   - Conditionally appends `Blocker()` if `template.blocker` is True.
   - Conditionally appends `AI()` if `template.ai` is True.
   - Calls `world.create_entity(*components)` and returns the entity ID.
   - Import components from `ecs.components` and `SpriteLayer` from `config`.

4. Extend `services/resource_loader.py` — add `load_entities(filepath: str)` static method:
   - Follow the exact same structure as `load_tiles()`: check file exists, parse JSON, validate it's a list, validate required fields per entry.
   - Required fields to validate: `id`, `name`, `sprite`, `sprite_layer`, `hp`, `max_hp`, `power`, `defense`, `mana`, `max_mana`, `perception`, `intelligence`.
   - Convert `color` from list to tuple (default `[255, 255, 255]` if missing).
   - Store `sprite_layer` as raw string (do NOT convert to SpriteLayer enum here — that happens in EntityFactory.create at creation time).
   - Parse `ai` (default True) and `blocker` (default True) as bools.
   - Create `EntityTemplate` instance and call `EntityRegistry.register(template)`.
   - Add import for `EntityTemplate` and `EntityRegistry` from `entities.entity_registry`.
  </action>
  <verify>
Run `python -c "from services.resource_loader import ResourceLoader; from entities.entity_registry import EntityRegistry; ResourceLoader.load_tiles('assets/data/tile_types.json'); ResourceLoader.load_entities('assets/data/entities.json'); t = EntityRegistry.get('orc'); print(t.name, t.hp, t.power)"` — should print "Orc 10 3".
  </verify>
  <done>EntityTemplate dataclass and EntityRegistry exist. ResourceLoader.load_entities() populates the registry from entities.json. EntityFactory.create() can build ECS entities from templates. All structures mirror the proven TileType/TileRegistry pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Fix startup ordering in main.py, migrate spawn_monsters, and add tests</name>
  <files>
    main.py
    services/map_service.py
    tests/verify_entity_factory.py
  </files>
  <action>
1. Fix `main.py` startup ordering in `GameController.__init__()`:
   - Add `from services.resource_loader import ResourceLoader` import at top.
   - After `self.map_service = MapService()` and before `world = get_world()`, add:
     ```python
     ResourceLoader.load_tiles("assets/data/tile_types.json")
     ResourceLoader.load_entities("assets/data/entities.json")
     ```
   - This ensures both registries are populated BEFORE `create_village_scenario(world)` is called.

2. Migrate `services/map_service.py`:
   - Replace `from entities.monster import create_orc` with `from entities.entity_factory import EntityFactory`.
   - In `spawn_monsters()`, replace `create_orc(world, x, y)` with `EntityFactory.create(world, "orc", x, y)`.
   - Do NOT delete `entities/monster.py` yet — leave it for backward compatibility but it should no longer be imported by map_service.

3. Create `tests/verify_entity_factory.py` with these test cases:
   - **test_entity_registry_load**: Call `EntityRegistry.clear()`, then `ResourceLoader.load_tiles("assets/data/tile_types.json")` and `ResourceLoader.load_entities("assets/data/entities.json")`. Assert `EntityRegistry.get("orc")` is not None. Assert its `name == "Orc"`, `hp == 10`, `power == 3`, `sprite == "O"`, `color == (0, 255, 0)`, `sprite_layer == "ENTITIES"`.
   - **test_entity_factory_create**: After loading registries, create a mock or real esper world, call `EntityFactory.create(world, "orc", 5, 10)`. Verify the returned entity has `Position(5, 10)`, `Stats` with hp=10/power=3, `Name("Orc")`, `Renderable` with sprite="O", `Blocker`, and `AI` components.
   - **test_entity_factory_unknown_template**: Assert `EntityFactory.create(world, "nonexistent", 0, 0)` raises `ValueError`.
   - **test_entity_registry_clear**: Load entities, call `EntityRegistry.clear()`, assert `EntityRegistry.get("orc")` is None.
   - Use the same test pattern as existing tests in `tests/` directory. Each test function should start with `EntityRegistry.clear()` + `TileRegistry.clear()` + `ResourceLoader.load_tiles(...)` + `ResourceLoader.load_entities(...)` for isolation.
   - Use `from ecs.world import get_world` or `import esper` to get a real ECS world for testing (check existing test files for the pattern used).
  </action>
  <verify>
Run `python -m pytest tests/verify_entity_factory.py -v` — all tests pass. Also run `python -m pytest tests/ -v` to verify no regressions in existing tests.
  </verify>
  <done>main.py calls both load_tiles() and load_entities() before map/entity creation. spawn_monsters() uses EntityFactory instead of create_orc(). All new and existing tests pass.</done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/verify_entity_factory.py -v` — all 4 tests pass.
2. `python -m pytest tests/ -v` — no regressions in existing tests.
3. `python -c "from entities.entity_registry import EntityRegistry, EntityTemplate; from entities.entity_factory import EntityFactory"` — imports succeed.
4. `python -c "from services.resource_loader import ResourceLoader; ResourceLoader.load_tiles('assets/data/tile_types.json'); ResourceLoader.load_entities('assets/data/entities.json'); from entities.entity_registry import EntityRegistry; print(EntityRegistry.all_ids())"` — prints `['orc']`.
</verification>

<success_criteria>
- EntityRegistry populated from entities.json via ResourceLoader.load_entities()
- EntityFactory.create(world, "orc", x, y) produces an entity with correct components matching the old create_orc() output
- main.py calls load_tiles() and load_entities() before create_village_scenario()
- spawn_monsters() uses EntityFactory, not create_orc()
- All tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/10-entity-map-templates/10-01-SUMMARY.md`
</output>
