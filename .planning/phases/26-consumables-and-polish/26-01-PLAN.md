---
phase: 26-consumables-and-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [ecs/components.py, entities/item_registry.py, services/resource_loader.py, entities/item_factory.py, assets/data/items.json, services/consumable_service.py]
autonomous: true

must_haves:
  truths:
    - "Consumable component exists in ECS"
    - "Items can be loaded with consumable properties from JSON"
    - "Health potions heal the player when used via ConsumableService"
    - "Consumed items are removed from inventory and world"
  artifacts:
    - path: "services/consumable_service.py"
      provides: "Item usage logic"
    - path: "assets/data/items.json"
      contains: "health_potion"
  key_links:
    - from: "services/consumable_service.py"
      to: "ecs/components.py"
      via: "Consumable component"
---

<objective>
Implement the data-driven foundation for consumable items and the core logic for using them.
</objective>

<execution_context>
@/home/peter/.gemini/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-consumables-and-polish/26-RESEARCH.md
@ecs/components.py
@entities/item_registry.py
@services/resource_loader.py
@entities/item_factory.py
@assets/data/items.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Consumable Component and Update Registry</name>
  <files>ecs/components.py, entities/item_registry.py, services/resource_loader.py, entities/item_factory.py</files>
  <action>
    1. In `ecs/components.py`, add `@dataclass class Consumable` with fields: `effect_type: str`, `amount: int`, and `consumed_on_use: bool = True`.
    2. In `entities/item_registry.py`, update `ItemTemplate` to include an optional `consumable: Optional[Dict] = None` field.
    3. In `services/resource_loader.py`, update `load_items` to read the `consumable` dictionary from JSON and pass it to the `ItemTemplate`.
    4. In `entities/item_factory.py`, update `create` to check if `template.consumable` exists, and if so, add a `Consumable` component to the entity using the data from the template.
  </action>
  <verify>Check that code compiles and ItemFactory can handle consumable data.</verify>
  <done>Consumable data pipeline is established from JSON to ECS component.</done>
</task>

<task type="auto">
  <name>Task 2: Implement ConsumableService and Update Item Data</name>
  <files>services/consumable_service.py, assets/data/items.json</files>
  <action>
    1. Create `services/consumable_service.py` with a `use_item(world, user_ent, item_ent)` static method.
    2. Logic:
       - Get `Consumable` component from `item_ent`.
       - If `effect_type == "heal_hp"`, get `Stats` from `user_ent`, heal by `amount` (clamped to `base_max_hp`), and dispatch `log_message`.
       - If `consumed_on_use` is True, remove `item_ent` from `Inventory` of `user_ent` and delete the entity from `world`.
       - Return `True` if used, `False` otherwise.
    3. Update `assets/data/items.json`: Add `"consumable": {"effect_type": "heal_hp", "amount": 10}` to the `health_potion` entry.
  </action>
  <verify>Run a test script that creates a player with low HP, uses a health potion via the service, and checks if HP increased and item was removed.</verify>
  <done>ConsumableService correctly applies effects and manages item lifecycle.</done>
</task>

</tasks>

<verification>
Create a temporary test script `tests/verify_consumables_foundation.py` that:
1. Loads items.
2. Creates a player and a health potion.
3. Damages the player.
4. Uses the potion via ConsumableService.
5. Asserts HP increased and potion entity is gone.
</verification>

<success_criteria>
- Consumable component is integrated into the ECS.
- Health potions can be defined in JSON and correctly instantiated.
- ConsumableService provides a clean API for item usage logic.
</success_criteria>

<output>
After completion, create `.planning/phases/26-consumables-and-polish/26-01-SUMMARY.md`
</output>
