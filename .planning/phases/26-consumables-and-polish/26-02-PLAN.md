---
phase: 26-consumables-and-polish
plan: 02
type: execute
wave: 2
depends_on: [26-01]
files_modified: [game_states.py, ecs/systems/action_system.py]
autonomous: false

must_haves:
  truths:
    - "Player can use items from inventory by pressing 'U'"
    - "Using an item costs a turn ONLY if the effect was applied"
    - "Failed item usage (e.g. at full health) does not cost a turn"
    - "Inventory UI displays description, material, and weight of the selected item"
    - "Inspection mode shows the same detailed physical information"
  artifacts:
    - path: "game_states.py"
      provides: "'Use' key handling and detailed item display"
    - path: "ecs/systems/action_system.py"
      provides: "Consolidated item description logic and updated inspection"
---

<objective>
Integrate consumable usage into the Inventory UI and enhance item representations with detailed physical descriptions across the UI and inspection modes.
</objective>

<execution_context>
@/home/peter/.gemini/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-consumables-and-polish/26-01-SUMMARY.md
@game_states.py
@ecs/systems/action_system.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 'Use' Key to InventoryState</name>
  <files>game_states.py</files>
  <action>
    1. In `game_states.py`, update `InventoryState.get_event`:
       - Add handling for `pygame.K_u`.
       - When pressed, get the selected item ID.
       - Call `consumable_service.use_item(self.world, self.player_entity, selected_item_id)`.
       - **Capture the return value (success/failure)**.
       - If usage was successful (`True`):
         - End the player's turn (`self.persist["turn_system"].end_player_turn()`).
         - Exit inventory back to "GAME" state.
       - If usage failed (`False`):
         - Stay in inventory, allowing the user to try something else (no turn cost).
    2. Import `consumable_service` at the top of the file.
  </action>
  <verify>Launch game with health potion. Test 'U' at full health (should stay in inventory, log message shown). Damage player, test 'U' (should close inventory, heal, and turn advance).</verify>
  <done>Player can use items from inventory with turn-cost logic based on successful application.</done>
</task>

<task type="auto">
  <name>Task 2: Consolidate Descriptive Logic and Update Inspection</name>
  <files>ecs/systems/action_system.py</files>
  <action>
    1. In `ecs/systems/action_system.py`, add a static method (or helper function) to generate a detailed item description.
    2. The helper should take an `entity_id` and return a string in the format:
       "[Base Description]\nMaterial: [material]\nWeight: [weight]kg"
       (Retrieve components: `Description`, `ItemMaterial`, `Portable`).
    3. Update `ActionSystem.confirm_action` (inspect mode logic) to use this helper when an item entity is encountered.
    4. Ensure it still includes the Name in yellow at the top as per existing pattern.
  </action>
  <verify>Use 'Inspect' mode on an item and verify the log shows the formatted description with material and weight.</verify>
  <done>Item description logic is centralized and used for inspection output.</done>
</task>

<task type="auto">
  <name>Task 3: Update InventoryState UI with Detailed Item Info</name>
  <files>game_states.py</files>
  <action>
    1. In `game_states.py`, update `InventoryState.draw`.
    2. When an item is selected, call the description helper (from `ActionSystem`) to get the detailed info.
    3. Render this information in a designated "Details" area of the inventory box (e.g., at the bottom or to the right of the list).
    4. Ensure descriptions with multiple lines (newlines) are handled correctly (simple split and vertical offset).
  </action>
  <verify>Open inventory, select various items, and verify that the description, material, and weight appear correctly in the UI.</verify>
  <done>Inventory UI provides comprehensive detail about the selected item.</done>
</task>

<task type="checkpoint:human-verify">
  <name>Final Verification: Consumables and Polish</name>
  <what-built>Consumable usage flow and enhanced physical descriptions in UI/Inspection</ what-built>
  <how-to-verify>
    1. Start the game.
    2. Find a health potion.
    3. Inspect it ('X' then 'Enter'): verify it shows "Material: glass" and "Weight: 0.5kg" in the log.
    4. Pick it up.
    5. Open inventory ('I').
    6. Select the potion: verify the UI displays its description, material, and weight.
    7. Press 'U' while at full HP: verify "already at full health" message and that you stay in inventory.
    8. Walk into a wall/enemy to lose HP.
    9. Use potion again: verify inventory closes, HP increases, and turns advanced by 1.
  </how-to-verify>
  <resume-signal>approved</resume-signal>
</task>

</tasks>

<verification>
Manual playtest of the full consumable loop (Pickup -> Inspect -> Use) and UI inspection.
</verification>

<success_criteria>
- The 'U' key functions correctly with success-based turn cost.
- Inventory UI and Inspection both show consistent, detailed item information (description, material, weight).
- Full health players are prevented from wasting healing items.
</success_criteria>

<output>
After completion, create `.planning/phases/26-consumables-and-polish/26-02-SUMMARY.md`
</output>
