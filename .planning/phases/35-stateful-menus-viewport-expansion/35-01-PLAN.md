---
phase: 35-stateful-menus-viewport-expansion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [ui/stack_manager.py, ui/windows/base.py, main.py, game_states.py, config.py]
autonomous: true

must_haves:
  truths:
    - "UI stack can hold multiple windows"
    - "Only the top window receives input"
    - "Game world rendering continues behind the modal"
  artifacts:
    - path: "ui/stack_manager.py"
      provides: "UIStack class"
    - path: "ui/windows/base.py"
      provides: "UIWindow base class"
  key_links:
    - from: "main.py"
      to: "ui/stack_manager.py"
      via: "persistent storage"
---

<objective>
Implement the core infrastructure for modal windows using a stack-based approach. This replaces the full-state transition for simple menus and allows for nested overlays.

Purpose: Decouple menus from the main game state machine and support layering.
Output: UIStack and UIWindow classes integrated into the game loop.
</objective>

<execution_context>
@/home/peter/.gemini/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-stateful-menus-viewport-expansion/RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UIStack and UIWindow base classes</name>
  <files>ui/stack_manager.py, ui/windows/base.py</files>
  <action>
    Create `ui/stack_manager.py` with a `UIStack` class that supports `push(window)`, `pop()`, `handle_event(event)`, `update(dt)`, and `draw(surface)`. 
    Create `ui/windows/base.py` with an abstract `UIWindow` class providing stubs for `handle_event`, `update`, and `draw`.
    Include a 'is_active()' method in UIStack to check if any windows are open.
  </action>
  <verify>Run a simple script to push/pop windows and check stack depth.</verify>
  <done>Infrastructure files exist and classes are defined according to Research specs.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate UIStack into GameController and Game State</name>
  <files>main.py, game_states.py, config.py</files>
  <action>
    1. Add `MENU` to `GameStates` enum in `config.py`.
    2. Instantiate `UIStack` in `GameController.__init__` and add it to `self.persist`.
    3. In `Game.get_event`, check `ui_stack.is_active()`. If true, delegate events to `ui_stack.handle_event(event)`. 
    4. If a window consumes the event (returns True), stop further processing.
    5. In `Game.draw`, call `ui_stack.draw(surface)` after `ui_system.process(surface)`.
    6. In `Game.update`, call `ui_stack.update(dt)`. If `ui_stack.is_active()`, skip world processing (pausing the game).
  </action>
  <verify>Manually verify that a dummy window can be pushed and it intercepts input/draws on top.</verify>
  <done>Game state delegates input and rendering to the UIStack when active.</done>
</task>

</tasks>

<verification>
Check that the game world is visible behind the stack (if transparency is used) and that world movement is blocked while the stack is active.
</verification>

<success_criteria>
1. UIStack exists and can manage multiple windows.
2. Game state correctly pauses its world-update logic when the stack is active.
3. Input is intercepted by the stack and not passed to the world.
</success_criteria>

<output>
After completion, create `.planning/phases/35-stateful-menus-viewport-expansion/35-01-SUMMARY.md`
</output>
