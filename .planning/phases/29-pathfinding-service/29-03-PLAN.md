---
phase: 29-pathfinding-service
plan: 03
type: execute
wave: 3
depends_on: [29-02]
files_modified: [tests/verify_pathfinding.py, tests/verify_npc_navigation.py]
autonomous: true
---

<objective>
Create comprehensive verification tests to ensure the pathfinding service correctly computes paths and that NPCs successfully navigate using these paths within the AI system.

Purpose: Guarantee the reliability and correctness of the new navigation infrastructure.
Output: Two test scripts (unit and integration) proving pathfinding works as intended.
</objective>

<execution_context>
@/home/peter/.gemini/get-shit-done/workflows/execute-plan.md
@/home/peter/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-pathfinding-service/29-01-SUMMARY.md
@.planning/phases/29-pathfinding-service/29-02-SUMMARY.md
@services/pathfinding_service.py
@ecs/systems/ai_system.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unit Tests for PathfindingService</name>
  <files>tests/verify_pathfinding.py</files>
  <action>
    Create a standalone test script `tests/verify_pathfinding.py`.
    
    Test Cases:
    1. **Direct Path**: (0,0) to (5,0) on an empty 10x10 grid returns a path of length 5.
    2. **Obstacle Avoidance**: (0,0) to (2,2) with a wall at (1,1) and (1,0) returns a valid cardinal path avoiding the walls.
    3. **Entity Blocker**: Same as #1 but with an entity at (2,0) with a `Blocker` component. Path should go around it.
    4. **Destination Blocker**: (0,0) to (2,0) where (2,0) has a `Blocker`. The path should successfully lead to (2,0) (testing the destination-walkability exception).
    5. **Unreachable**: (0,0) to (5,5) when the target is completely boxed in by walls. Service should return an empty list.
  </action>
  <verify>
    Run `python3 tests/verify_pathfinding.py` and ensure all test cases pass.
  </verify>
  <done>
    `PathfindingService` is unit-tested and handles various grid/blocker scenarios correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration Tests for NPC Navigation</name>
  <files>tests/verify_npc_navigation.py</files>
  <action>
    Create an integration test `tests/verify_npc_navigation.py` using a mock `esper` world.
    
    Test Cases:
    1. **NPC Follows Path**: Give an NPC a `PathData` with a 3-step route. Run `AISystem.process` 3 times and verify the NPC's `Position` matches the path steps.
    2. **NPC Recomputes on Target Move**: Set NPC to `CHASE` player. Run one turn. Move player to a new location. Run another turn. Verify NPC moves towards the NEW location (proving recomputation).
    3. **NPC Waits if Path Blocked**: Put a second NPC on the path of the first NPC. Verify the first NPC does not move onto the blocked tile.
  </action>
  <verify>
    Run `python3 tests/verify_npc_navigation.py` and ensure all integration scenarios pass.
  </verify>
  <done>
    NPC navigation via `AISystem` and `PathData` is integration-tested and handles dynamic changes.
  </done>
</task>

</tasks>

<verification>
Run both test scripts:
`python3 tests/verify_pathfinding.py`
`python3 tests/verify_npc_navigation.py`
</verification>

<success_criteria>
1. All unit tests for `PathfindingService` pass.
2. NPCs correctly consume steps from `PathData` in a mocked world.
3. Path recomputation is triggered when targets move or paths are blocked.
</success_criteria>

<output>
After completion, create `.planning/phases/29-pathfinding-service/29-03-SUMMARY.md`
</output>
