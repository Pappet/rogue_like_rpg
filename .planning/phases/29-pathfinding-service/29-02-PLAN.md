---
phase: 29-pathfinding-service
plan: 02
type: execute
wave: 2
depends_on: [29-01]
files_modified: [ecs/systems/ai_system.py]
autonomous: true
---

<objective>
Update the `AISystem` to utilize the `PathData` component, allowing NPCs to navigate purposefully to targets, and implement path invalidation/recomputation logic for dynamic environments.

Purpose: Enable NPCs to follow purposeful paths towards a destination.
Output: Updated `AISystem` with path consumption and recomputation.
</objective>

<execution_context>
@/home/peter/.gemini/get-shit-done/workflows/execute-plan.md
@/home/peter/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-pathfinding-service/29-01-SUMMARY.md
@ecs/systems/ai_system.py
@services/pathfinding_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update AISystem to Consume PathData</name>
  <files>ecs/systems/ai_system.py</files>
  <action>
    Modify the `AISystem` to handle entities with a `PathData` component.
    
    Requirements:
    - Update `AISystem._dispatch` or relevant behavior methods to prioritize `PathData` consumption.
    - If an entity has `PathData` and it's NOT empty:
      1. Pop the first element `(nx, ny)` from the `path`.
      2. Check if the tile is blocked by another entity (using `_get_blocker_at`).
      3. If blocked: Invalidate the path (clear `PathData.path`) and either wait or recompute (see Task 2).
      4. If not blocked: Update `Position.x, Position.y` to `(nx, ny)` and add `(nx, ny)` to `claimed_tiles`.
    - Handle `AISystem._chase` by using `PathfindingService` to populate `PathData` if it's missing or if the target's position has moved since the last computation.
    - Ensure `PathData` is importable in `AISystem.py`.
  </action>
  <verify>
    Check for syntax errors and correct imports.
  </verify>
  <done>
    `AISystem` consumes `PathData` for purposeful navigation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Path Invalidation and Recomputation Logic</name>
  <files>ecs/systems/ai_system.py</files>
  <action>
    Implement logic to handle stale or blocked paths within `AISystem`.
    
    Requirements:
    - **Destination Invalidation**: In the `CHASE` handler, if `PathData.destination` != `player_pos`, recompute the path using `PathfindingService.get_path`.
    - **Blockage Invalidation**: If the next step in `PathData.path` is blocked by an entity (other than the destination), clear the path and attempt an immediate recompute or skip the turn.
    - **Fallback**: Maintain the existing `_wander` logic as a fallback if pathfinding fails or no path is available.
    - **Diagonal Rule**: Ensure `AISystem` remains cardinal-only by only accepting steps from a cardinal-pathfinding-service.
  </action>
  <verify>
    Check that `PathfindingService` is imported and called correctly when `PathData` needs update.
  </verify>
  <done>
    `AISystem` correctly invalidates and recomputes paths when environments or destinations change.
  </done>
</task>

</tasks>

<verification>
Check `ecs/systems/ai_system.py` for integration of `PathfindingService` and `PathData`.
Verify that `CHASE` logic uses A* instead of simple Manhattan.
</verification>

<success_criteria>
1. NPCs with `PathData` take steps along the precomputed path.
2. If the next step is blocked, the path is cleared and the NPC skips the turn (or recomputes).
3. If the target moves, the path is recomputed to the new location.
</success_criteria>

<output>
After completion, create `.planning/phases/29-pathfinding-service/29-02-SUMMARY.md`
</output>
