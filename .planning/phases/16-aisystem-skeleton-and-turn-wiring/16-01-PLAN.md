---
phase: 16-aisystem-skeleton-and-turn-wiring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ecs/systems/ai_system.py
  - game_states.py
  - tests/verify_ai_system.py
autonomous: true

must_haves:
  truths:
    - "After the player acts, enemy turns pass without error and play returns to the player"
    - "AI entities on a different map layer than the player do not act during enemy turn"
    - "Entities with a Corpse component are never processed by AISystem"
    - "AISystem does not run during PLAYER_TURN, TARGETING, or WORLD_MAP states"
    - "end_enemy_turn() is called exactly once per enemy turn after all entity decisions are processed"
  artifacts:
    - path: "ecs/systems/ai_system.py"
      provides: "AISystem processor with process() and _dispatch()"
      exports: ["AISystem"]
      contains: "class AISystem"
      min_lines: 30
    - path: "game_states.py"
      provides: "AISystem initialization and ENEMY_TURN wiring"
      contains: "ai_system.process"
    - path: "tests/verify_ai_system.py"
      provides: "Verification tests for all 6 requirements"
      contains: "def test_ai_system"
      min_lines: 40
  key_links:
    - from: "game_states.py"
      to: "ecs/systems/ai_system.py"
      via: "explicit call in update() ENEMY_TURN branch"
      pattern: "self\\.ai_system\\.process"
    - from: "ecs/systems/ai_system.py"
      to: "ecs/systems/turn_system.py"
      via: "turn_system.end_enemy_turn() call after entity loop"
      pattern: "turn_system\\.end_enemy_turn"
    - from: "ecs/systems/ai_system.py"
      to: "ecs/components.py"
      via: "esper.get_components query for AI, AIBehaviorState, Position"
      pattern: "get_components.*AI.*AIBehaviorState.*Position"
---

<objective>
Create AISystem processor, wire it into the game loop replacing the ENEMY_TURN stub, and verify all six requirements with tests.

Purpose: Enemy turns are fully owned by AISystem instead of an inline stub. The skeleton dispatches IDLE no-ops, skips dead and off-layer entities, and completes turns cleanly.
Output: Working AISystem processor, updated game_states.py wiring, passing verification tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-aisystem-skeleton-and-turn-wiring/16-RESEARCH.md
@ecs/systems/movement_system.py (reference pattern for Processor structure)
@ecs/systems/action_system.py (reference pattern for explicit-call system)
@ecs/components.py (AI, AIBehaviorState, AIState, Alignment, Corpse, Position)
@game_states.py (stub to replace at lines 309-311, startup pattern at lines 88-129)
@ecs/systems/turn_system.py (TurnSystem, end_enemy_turn API)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AISystem processor and wire into game loop</name>
  <files>ecs/systems/ai_system.py, game_states.py</files>
  <action>
Create `ecs/systems/ai_system.py` with class AISystem(esper.Processor):

1. `__init__(self)`: call `super().__init__()`, no stored state needed for skeleton.

2. `process(self, turn_system, map_container, player_layer)`:
   - Guard: if `turn_system.current_state != GameStates.ENEMY_TURN`, return immediately (AISYS-01, AISYS-02).
   - Iterate `list(esper.get_components(AI, AIBehaviorState, Position))` — use `list()` wrapper to prevent modification-during-iteration (matches movement_system.py pattern).
   - For each entity: skip if `pos.layer != player_layer` (SAFE-02), skip if `esper.has_component(ent, Corpse)` (AISYS-05).
   - Call `self._dispatch(ent, behavior, pos)` for surviving entities (AISYS-03).
   - After loop: call `turn_system.end_enemy_turn()` exactly once (AISYS-04).

3. `_dispatch(self, ent, behavior, pos)`:
   - Match on `behavior.state`: IDLE -> pass, WANDER -> pass (stub), CHASE -> pass (stub), TALK -> pass (stub).

Imports: `esper`, `GameStates` from config, `AI, AIBehaviorState, Corpse, Position, AIState` from ecs.components.

Then modify `game_states.py`:

A. Add import at top: `from ecs.systems.ai_system import AISystem`

B. In `Game.startup()` (after death_system init, around line 115, BEFORE the "clear existing processors" loop):
   ```python
   self.ai_system = self.persist.get("ai_system")
   if not self.ai_system:
       self.ai_system = AISystem()
       self.persist["ai_system"] = self.ai_system
   ```
   Do NOT add AISystem to the `esper.add_processor()` calls or the `remove_processor` loop — it is an explicit-call system per project convention.

C. In `Game.update()`, replace lines 309-311 (the stub):
   ```python
   # OLD (remove):
   if self.turn_system and not (self.turn_system.is_player_turn() or self.turn_system.current_state == GameStates.TARGETING):
       self.turn_system.end_enemy_turn()
   ```
   With:
   ```python
   # Handle enemy turn via AISystem
   if self.turn_system and self.turn_system.current_state == GameStates.ENEMY_TURN:
       try:
           pos = esper.component_for_entity(self.player_entity, Position)
           player_layer = pos.layer
       except KeyError:
           player_layer = 0
       self.ai_system.process(self.turn_system, self.map_container, player_layer)
   ```
   Key change: condition is now explicit `== GameStates.ENEMY_TURN` instead of negation of other states. This ensures WORLD_MAP state does not trigger enemy turns (AISYS-02).
  </action>
  <verify>
`python -c "from ecs.systems.ai_system import AISystem; print('import ok')"` succeeds.
`python -c "import ast; ast.parse(open('game_states.py').read()); print('syntax ok')"` succeeds.
Grep game_states.py for "end_enemy_turn" — should appear only inside ai_system.py, NOT in game_states.py update() method anymore.
  </verify>
  <done>AISystem class exists with process() and _dispatch(). game_states.py initializes AISystem via persist pattern and calls it explicitly during ENEMY_TURN. Old stub is removed.</done>
</task>

<task type="auto">
  <name>Task 2: Create verification tests for all requirements</name>
  <files>tests/verify_ai_system.py</files>
  <action>
Create `tests/verify_ai_system.py` following existing test patterns (see tests/verify_entity_factory.py, tests/verify_action_wiring.py).

Tests to write:

1. `test_ai_system_ends_enemy_turn()` — AISYS-04:
   - reset_world(), create TurnSystem, call end_player_turn() to set ENEMY_TURN.
   - Create one AI entity with AI(), AIBehaviorState(AIState.IDLE, Alignment.HOSTILE), Position(1, 1, layer=0).
   - Call ai_sys.process(turn, None, player_layer=0).
   - Assert turn.current_state == GameStates.PLAYER_TURN.

2. `test_ai_system_skips_corpse()` — AISYS-05:
   - Same setup but add Corpse() to the entity.
   - Call process, assert turn still completes (state == PLAYER_TURN).
   - The entity should not cause errors despite having Corpse.

3. `test_ai_system_skips_wrong_layer()` — SAFE-02:
   - Create entity on layer=2, call process with player_layer=0.
   - Assert turn completes. Entity was skipped (no error).

4. `test_ai_system_noop_in_player_turn()` — AISYS-02:
   - Do NOT call end_player_turn (state stays PLAYER_TURN).
   - Call process. Assert state remains PLAYER_TURN (system was a no-op, did not call end_enemy_turn).

5. `test_ai_system_noop_in_targeting()` — AISYS-02:
   - Set turn state to TARGETING. Call process.
   - Assert state remains TARGETING.

6. `test_ai_system_dispatches_idle()` — AISYS-03:
   - Create entity with AIState.IDLE on correct layer, no Corpse.
   - Call process. Should complete without error (dispatch runs idle no-op).
   - Assert turn ended.

7. `test_ai_system_empty_world()` — edge case:
   - No AI entities at all. Call process during ENEMY_TURN.
   - Assert turn still ends (end_enemy_turn called unconditionally after loop).

Use imports: `esper`, `reset_world` from ecs.world, components from ecs.components, AISystem from ecs.systems.ai_system, TurnSystem from ecs.systems.turn_system, GameStates from config.
  </action>
  <verify>`python -m pytest tests/verify_ai_system.py -v` — all 7 tests pass.</verify>
  <done>All 7 verification tests pass, covering AISYS-01 through AISYS-05 and SAFE-02.</done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/verify_ai_system.py -v` — all tests pass
2. `python -m pytest tests/ -v` — no regressions in existing tests
3. `python -c "from ecs.systems.ai_system import AISystem; a = AISystem(); print('AISystem instantiates')"` — confirms class works
4. Grep `game_states.py` for old stub pattern `not (self.turn_system.is_player_turn` — should return zero matches
5. Grep `game_states.py` for new pattern `== GameStates.ENEMY_TURN` — should match in update()
</verification>

<success_criteria>
- AISystem processor exists at ecs/systems/ai_system.py
- game_states.py initializes AISystem via persist pattern and calls it during ENEMY_TURN only
- Old inline stub (lines 309-311) is completely removed
- All 7 verification tests pass
- No regressions in existing test suite
- AISYS-01, AISYS-02, AISYS-03, AISYS-04, AISYS-05, SAFE-02 all satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/16-aisystem-skeleton-and-turn-wiring/16-01-SUMMARY.md`
</output>
